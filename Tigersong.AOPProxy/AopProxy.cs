//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a Tigersong Template.
//
//     DO NOT MODIFY contents of this file. Changes to this
//     file will be lost if the code is regenerated.
//     Author:Haibin Jiang
// </autogenerated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using System.Reflection;
using System.Runtime.Remoting.Messaging;
using System.Runtime.Remoting.Proxies;

namespace Tigersong.AOPProxy
{
	/// <summary>
	/// AOP动态注入
	/// </summary>
	/// <typeparam name="T"></typeparam>
	public class AopProxy<T> : RealProxy
	{
		private T _realObject;

		public AopProxy(T realObject) : base(typeof(T))
		{
			_realObject = realObject;
		}
		/// <summary>
		/// 返回方法消息
		/// </summary>
		/// <param name="returnValue"></param>
		/// <param name="callMessage"></param>
		/// <returns></returns>
		private IMessage GetReturnMessage(object returnValue, IMethodCallMessage callMessage)
		{
			IMessage returnMessage = new ReturnMessage(returnValue, callMessage.Args, callMessage.ArgCount - callMessage.InArgCount, callMessage.LogicalCallContext, callMessage);
			return returnMessage;
		}
		/// <summary>
		/// 返回方法消息
		/// </summary>
		/// <param name="returnValue"></param>
		/// <param name="methodParameter"></param>
		/// <param name="callMessage"></param>
		/// <returns></returns>
		private IMessage GetReturnMessage(object returnValue, MethodParameters methodParameter, IMethodCallMessage callMessage)
		{
			IMessage returnMessage = new ReturnMessage(returnValue, methodParameter.Argugemts, callMessage.ArgCount - callMessage.InArgCount, callMessage.LogicalCallContext, callMessage);
			return returnMessage;
		}

		/// <summary>
		/// 拦截所有方法的调用
		/// </summary>
		/// <param name="msg"></param>
		/// <returns></returns>
		public override IMessage Invoke(IMessage msg)
		{
			IMessage returnMessage;
			IMessage message;
			//拦截方法调用的消息接口
			IMethodCallMessage methodCallMessage = msg as IMethodCallMessage;
			//方法的参数
			MethodParameters methodParameter = new MethodParameters(methodCallMessage.Args);
			//执行前调用方法
			object handleOnEntry = DelegateContainer.GetHandle(typeof(T).FullName, methodCallMessage.MethodName, InterceptionType.OnEntry);
			if (handleOnEntry != null)
			{
				((AOPDelegate.OnEntry)handleOnEntry)(methodCallMessage.MethodName, methodParameter);
			}
			try
			{
				try
				{
					methodParameter.ReturnValue = methodCallMessage.MethodBase.Invoke(_realObject, methodParameter.Argugemts);
					object handleOnSuccess = DelegateContainer.GetHandle(typeof(T).FullName, methodCallMessage.MethodName, InterceptionType.OnSuccess);
					if (handleOnSuccess != null)
					{
						((AOPDelegate.OnSuccess)handleOnSuccess)(methodParameter);
					}
					message = GetReturnMessage(methodParameter.ReturnValue, methodParameter, methodCallMessage);
				}
				catch (Exception ex)
				{
					methodParameter.Exception = ex;
					methodParameter.MethodFlow = FlowBehavior.ThrowException;
					object handleOnException = DelegateContainer.GetHandle(typeof(T).FullName, methodCallMessage.MethodName, InterceptionType.OnException);
					if (handleOnException != null)
					{
						((AOPDelegate.OnException)handleOnException)(methodParameter);
					}
					object handleOnLogException = DelegateContainer.GetHandle(typeof(T).GetInterfaces()[0].FullName, "LogException", InterceptionType.OnLogException);
					if (handleOnLogException != null)
					{
						Dictionary<string, object> strs = new Dictionary<string, object>();
						ParameterInfo[] parameters = ((MethodInfo)methodCallMessage.MethodBase).GetParameters();
						for (int i = 0; i < methodCallMessage.ArgCount; i++)
						{
							string name = parameters[i].Name;
							strs.Add(name, methodCallMessage.Args[i]);
						}
						((AOPDelegate.OnLogException)handleOnLogException)(methodCallMessage.MethodName, strs, (ex.InnerException != null ? ex.InnerException : ex));
					}
					switch (methodParameter.MethodFlow)
					{
						case FlowBehavior.Continue:
						case FlowBehavior.Return:
						default:
							returnMessage = GetReturnMessage(methodParameter.ReturnValue, methodParameter, methodCallMessage);
							break;
						case FlowBehavior.ThrowException:
							returnMessage = new ReturnMessage(methodParameter.Exception, methodCallMessage);
							break;
					}
					message = returnMessage;
				}
			}
			finally
			{
				object handleOnExit = DelegateContainer.GetHandle(typeof(T).FullName, methodCallMessage.MethodName, InterceptionType.OnExit);
				if (handleOnExit != null)
				{
					((AOPDelegate.OnExit)handleOnExit)(methodCallMessage.MethodName, methodParameter);
				}
			}
			return message;
		}
	}
}
